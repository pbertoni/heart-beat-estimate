\section{C/C++}
	\subsection{Classificazione del linguaggio} %~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Il C è stato sviluppato nel 1972 da Dennis Ritchie e i suoi collaboratori. Lo scopo dei progettisti era di sintetizzare in un unico linguaggio le caratteristiche di: \mylist{ essere ad {\em alto livello}, ovvero di offrire costrutti per programmi portabili, in grado di non dipendere dalla macchina usata per la progettazione (caratteristica garantita dalla standardizzazione {\em ANSI C}); permettere uno controllo a {\em basso livello}, cioè la raggiungibilità del singolo bit di memoria nello spazio dedicato al programma dalla macchina, per la massima ottimizzazione delle prestazioni.}
I due presupposti, che a prima vista possono sembrare contradditori, sono stati rispettati dando origine al linguaggio probabilmente più diffuso nella storia, sebbene in ambiti specifici come quello scientifico o dei sistemi informativi esso sia stato surclassato da linguaggi dedicati. I settori dove esso predomina e dominerà per molto tempo sono quello dei sistemi operativi, del controllo dei processi industriali e dei sistemi {\em real time response}; essi hanno in comune una strettissima tolleranza su faults più o meno gravi del software/hardware, e la stabilità del C è buon attributo per l'affidabilità di questi sistemi.
Con la diffusione del paradigma di programmazione OOP (object oriented programming), si ritiene che i linguaggi procedurali non siano i più efficienti o intuitivi per alcune grandi famiglie di problemi dove gli enti principali della computazione possono esser pensati in termini di classi e oggetti. Il C++ viene pensato in questo ambito e basato su due punti imprescindibili: \mylist{offrire al programmatore costrutti di OOP più semplici possibile, conservando un'alta efficienza del codice; mantenere la massima compatibilità col linguaggio C, per non rendere di classe {\em legacy} il software prodotto antecedentemente e per permettere di gestire sottoproblemi prettamente procedurali nel loro modo nativo.}
La vastità del C++ ha storicamente svantaggiato la sua standardizzazione, diversamente dal C: molto spesso i developers preferiscono concentrarsi su una specifica piattaforma o sistema per sfruttarla al massimo, sacrificando la portabilità. Nell'appendice C saranno elencate le conseguenze di questo problema nell'ambito dell'elaborato.
	\subsection{Allocazione dinamica} %~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Un oggetto (un dato aggregato, una variabile) può essere allocato in memoria \mylist{ {\em staticamente} in una posizione fissa per tutta la durata dell'esecuzione; {\em automaticamente} nello stack a seguito delle chiamate e dei ritorni di funzione; {\em dinamicamente} mediante variabili dette {\em puntatori}. }
I primi due metodi hanno forti limitazioni: nell'allocazione statica è necessario conoscere, al momento di compilazione, le dimensioni delle variabili e non è possibile eliminare dalla memoria oggetti non più necessari con evidente spreco di spazio. Nell'allocazione automatica invece i dati non possono persistere per più chiamate di funzioni \cite{WIKI}.

Allocando dinamicamente in uno spazio di memoria chiamato {\em heap} è possibile sopperire a tutte queste lacune: il programmatore ha il comando totale dei dati, accedendo a variabili aventi come valore un {\em indirizzo} di un'altra variabile: è questa una definizione di puntatore.

Nell'elaborato le primitive di allocazione dinamica sono servite principalmente a memorizzare temporaneamente i frames in attesa di gestire un blocco di processing, oltre alle strutture dati intermedie durante l'elaborazione delle serie temporali.
	\subsection{Struttura del programma} %~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Il software prodotto nell'elaborato è concettualmente divisibile in due classi, sebbene al loro interno esse siano fortemente imperative. La classe esterna, dove risiede il {\em main} dell'applicativo, si incarica di inizializzare gli oggetti che verranno usati generalmente da ogni ciclo di acquisizione e processing: tra essi si annoverano per esempio il responsabile della comunicazione col device di acquisizione video, il puntatore all'{\em Engine} Matlab\rtm (che verrà a breve presentato), la finestra grafica ove la cattura del device viene istantaneamente mostrata, e un buffer per la memorizzazione dei frames, in attesa che vengano inviati al processing vero e proprio.

La classe interna possiede una coda FIFO di \mymath{N} frames entro i quali deve individuare una traccia del battito cardiaco. Al termine di ogni periodo di acquisizione, questa classe viene istanziata in un oggetto al quale, tramite una chiamata esterna del main ad un metodo {\em public}, verrà assegnato il compito specificato, nei modi e nelle tecniche concettualmente sintetizzati nel capitolo 3. Al termine del calcolo i risultati verranno presentati sia mediante forma grafica che su {\em standard output}.
	\subsection{Compilazione precondizionale} %~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Una grande opportunità messa a disposizione da C/C++ è di effettuare compilazioni molto diverse dello stesso programma, includendo/escludendo o modificando delle sue sezioni al variare di pre-istruzioni dette {\em macros}. Sia in fase di debug che in fase di test o di release, quindi nella pressoché totalità del tempo dedicato allo sviluppo del software, può essere infatti molto utile concentrarsi su specifiche sezioni dell'esecuzione, oppure si può volerne tralasciare altre, per motivi di sicurezza o di non pertinenza, oppure ancora si può voler variare strutturalmente il behaviour del software a fronte degli stessi input: le possibilità sono numerosissime. 

Si può obiettare che tutto questo sia realizzabile mediante i soli costrutti {\em sequenziale, condizionale} e {\em iterativo} offerti dal linguaggio C. Questo è formalmente garantito dal teorema di Bohn-Jacopini, ma la compilazione precondizionale, poichè composta per definizione da costrutti condizionali {\em if-then-else}, rispetta appunto il teorema. Infine essa consente di pilotare il codice in modo esterno, pulito, visibile, alleggerendo inoltre le dimensioni del codice macchina prodotto, il quale nulla potrà sapere di ciò che è avvenuto prima della sua compilazione.

Per un'idea di come questo insieme di opportunità sia stato utilizzato si rimanda all'appendice B: Parametri.
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{OpenCV}
	\subsection{Un po' di storia}
Il mondo dell'opensource ha prodotto moduli e librerie che a volte si sono affermati come standards nell'Information Technology e nell'industria, dimostrando l'effettiva capacità di questa corrente di pensiero di generare software utilizzabile, adattabile ed estremamente efficiente. Un caso concreto è la {\em Open Computer Vision} library, inizialmente patrocinata da IBM e poi presa in gestione da terze parti.
L'ambiente dove si propone OpenCV è quello del riconoscimento e della gestione dell'informazione fotografica e video da parte delle macchine. 

Inizialmente sfruttata nell'elaborato per gestire il riconoscimento facciale tramite tecniche HAAR come accennato nell'introduzione, dopo l'eliminazione di questa feature OpenCV è rimasta parte integrante del codice, per l'utilizzo delle due classi che saranno ora presentate.
	\subsection{Classe Mat}
Un oggetto Mat è l'istanza di una matrice di numeri dello stesso tipo (in senso informatico).
Come detto nel capitolo 3 alla sezione ``Individuazione del fenomeno'', un'immagine è un vettore di tre matrici bidimensionali, mappanti ciascuna una diversa intensità cromatica fondamentale in ogni punto spaziale. E' ragionevole quindi che Mat sia stata sviluppata principalmente sotto la prospettiva di rappresentare immagini, ma conserva validità generale: se ne è fatto largo uso anche nella gestione delle serie temporali, concettualmente vettori monodimensionali. La scrittura matriciale come un vettore di tre vettori (uno per canale) ha alleggerito notevolmente la gestione del codice.
	\subsection{Classe CvCapture}
Rappresenta quanto più astrattamente possibile un'acquisizione video. Due costruttori distinti permettono poi di aprire una cattura da camera (si è sperimentata una grande compatibilità) o da file in formato AVI. E' possibile poi nei due casi effettuare operazioni diverse, come il focus sulla videocamera, la gestione della compressione del file, {\em etc}. Il programma necessita di una cattura video per non terminare in fase di inizializzazione.
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Matlab}
	\subsection{Classificazione del linguaggio}
Matlab è un ambiente di sviluppo prodotto da {\em MathWorks} per problemi di calcolo numerico e analisi dei dati. Comprende un ambiente grafico, un linguaggio (riferito indifferentemente come ``Matlab''), un interprete ad esso correlato e uno strumento CAD per la progettazione e simulazione di sistemi (Simulink).
Milioni di ingegneri e ricercatori utilizzano Matlab per i più disparati argomenti, come la biochimica, l'analisi statistica, il calcolo simbolico, l'analisi finanziaria e il digital signal processing \cite{MATLAB}.

Il nome è la sigla di MATrix LABoratory e bene fissa la struttura dati fondamentale del linguaggio: la matrice numerica. Ogni variabile Matlab è una matrice, al limite una 1x1, e tutte le operazioni sulle matrici godono di efficienza, leggibilità e scrivibilità molto elevate.
	\subsection{Integrazione con programmi C++}
Non essendo un linguaggio general-purpose ma offrendo una grande potenza in task scientifiche, nel tempo è emersa la convenienza di altro software ad appoggiarsi a un interprete Matlab, per sottoproblemi matematici particolarmente gravosi. Attualmente è supportato l'interfacciamento a run-time (si ricorda che Matlab è interpretato) con: Java, COM, .NET, Fortran e C/C++. In particolare per quest'ultimo, dopo aver incluso header e linkato librerie opportuni, nel sorgente C++ ogni operazione con Matlab verrà demandata a un oggetto Engine, visibile in figura \ref{fig:uml}.
Il motore Matlab offre primitive per il parsing in/out di codice Matlab e per il load/store di variabili nel workspace, oltre alla possibilità di creare e gestire finestre grafiche totalmente indipendenti dal processo main.
	\subsection{Utilizzo nell'elaborato}
E' lecito obiettare ora che le matrici elaborate dal programma potevano essere gestite in Matlab piuttosto che con le strutture OpenCV. Così non è stato, poiché si sarebbe sacrificata notevolmente la scrivibilità del codice, a giudizio del programmatore. Inoltre OpenCV dispone di alternative (classe Mat) rispettabili.
Il software scritto si è invece appoggiato a Matlab per due ragioni: \mylist{Richiamare funzioni e script di terze parti affidabili, velocemente e senza effettuare un porting (che può sempre essere fonte di errori); graficare i dati ottenuti durante le diverse fasi del processing, cosa peraltro non possibile senza qualche tipo di pacchetto grafico.}
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{FFTW}
E' una libreria di routines C per computare la trasformata di Fourier discreta DFT in una o più dimensioni, di dimensione arbitraria, sia per sequenze reali che complesse, oltre ad implementare le trasformate seno/coseno per sequenze dispari/pari.
La libreria è incentrata sulla portabilità e questo la spinge ad avere prestazioni costanti su benchmarks di macchine molto diverse \cite{FFTW}.
Peculiare è l'implementazione adattiva: il programmatore non richiama una funzione {\em trasforma}(), ma definisce un {\em plan} che si incarichi di gestire ogni richiesta di trasformate. A run-time il plan cerca di ottimizzare le prestazioni di FFTW operando diverse scelte algoritmiche per le trasformate domandate, con lo scopo di assestarsi, dove l'uso della libreria è massiccio, su un ottimo specifico per la macchina ove gira.
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Diagramma delle classi}
\singlefig{informatico/uml.png}{Diagramma UML delle classi del programma.}{13.0}{uml}